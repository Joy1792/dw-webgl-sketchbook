<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  
  <script src="../lib/gl-matrix-2.4.0/gl-matrix.js"></script>
  
  <script src="../dwgl/dw_gl.js"></script>
  <script src="../dwgl/dw_utils.js"></script>
  <script src="../dwgl/dw_app.js"></script>
  <script src="../dwgl/dw_orbit.js"></script>
  <script src="../dwgl/dw_geometry.js"></script>

  
  <link rel="stylesheet" href="../css/style.css">
     
<script id="webgl2.vs_draw" type="x-shader/x-fragment">
  #version 300 es

  #ifdef GL_ES
    precision highp float;
    precision highp int;
  #endif
  
  in vec3 pos;
  in vec3 col;
  in vec3 nml;
  
  uniform mat4 m4_projection;
  uniform mat4 m4_modelview;
  uniform mat3 m3_normals;
  
  out vec3 vpos;
  out vec3 vcol;
  out vec3 vnml;
  
  void main(){
    gl_Position = m4_projection * m4_modelview * vec4(pos, 1.0);
    vpos = (m4_modelview * vec4(pos, 1.0)).xyz;
    vcol = col;
    vnml = m3_normals * nml;
  }
</script>


<script id="webgl2.fs_draw" type="x-shader/x-fragment">
  #version 300 es

  #ifdef GL_ES
    precision highp float;
    precision highp int;
  #endif
  
  in vec3 vpos;
  in vec3 vcol;
  in vec3 vnml;
    
  out vec4 fragcol;
  
  void main(){
   
    float kd = max(dot(normalize(-vpos), normalize(vnml)), 0.0);
    vec3 rgb = (normalize(vcol));
    // vec3 rgb = vec3(1.0);
    fragcol = vec4(kd * rgb, 1);
    fragcol.rgb = pow(fragcol.rgb, vec3(1.0/2.2));
  }
</script>

    
</head>
<body>

  <div id="hud">
    <div id="sketch-title"></div>
    <div id="sketch-stats"></div>
  </div>
  
  <script>

    'use strict';
    
    document.oncontextmenu = function() { return false; }
    document.onmousedown   = function() { return false; }

 
    Dw.start('Subdivision Cube', function(app){
    
      var canvas;
      var gl;
      
      var shader;
      var model;
      
      var m4_modelview  = mat4.create();
      var m4_projection = mat4.create();
      var m3_normals    = mat3.create();
         
      var orbit;
      
      app.init = function(){
        console.log(this);
        app.webgl_attributes.antialias = true;
      }
      
      
      app.setup = function(){
        
        canvas = this.canvas;
        gl = this.gl;
       
        orbit = new Dw.OrbitControl(this);
        

        // create Shader
        var vs = document.getElementById("webgl2.vs_draw").textContent;
        var fs = document.getElementById("webgl2.fs_draw").textContent;
        
        shader = new Dw.Shader(gl, {vs:vs, fs:fs});
        
        // create geometry, vbo
        var subdivcube = new Dw.Cube().create(3);

        var faces = subdivcube.faces;
        var verts = subdivcube.verts;

        var faces_num = subdivcube.faces_num;
        var verts_num = subdivcube.verts_num;
                
        var pos = new Float32Array(faces_num * (3+3) * 3);
        var col = pos;
        var nml = pos;
        
        var flat_shading = true;
        
        var fi, v0, v1, v2, v3, nx, ny, nz;
        
        // vertex positions
        for(var i = 0, vi = 0; i < faces_num; i++){
          var face = faces[i];
          v0 = face[0] * 3;
          v1 = face[1] * 3;
          v2 = face[2] * 3;
          pos[vi++] = verts[v0++]; pos[vi++] = verts[v0++]; pos[vi++] = verts[v0++];      
          pos[vi++] = verts[v1++]; pos[vi++] = verts[v1++]; pos[vi++] = verts[v1++];
          pos[vi++] = verts[v2++]; pos[vi++] = verts[v2++]; pos[vi++] = verts[v2++];
          
          v0 = face[0] * 3;
          v2 = face[2] * 3;
          v3 = face[3] * 3;
          pos[vi++] = verts[v0++]; pos[vi++] = verts[v0++]; pos[vi++] = verts[v0++];  
          pos[vi++] = verts[v2++]; pos[vi++] = verts[v2++]; pos[vi++] = verts[v2++];
          pos[vi++] = verts[v3++]; pos[vi++] = verts[v3++]; pos[vi++] = verts[v3++];
        }  

        // use face center as face normals for flat shading
        if(flat_shading){
          nml = new Float32Array(faces_num * (3+3) * 3);

          for(var i = 0, ni = 0; i < faces_num; i++){
            var face = faces[i];
            v0 = face[0] * 3;
            v1 = face[1] * 3;
            v2 = face[2] * 3;
            v3 = face[3] * 3;
            
            nx = (verts[v0++] + verts[v1++] + verts[v2++] + verts[v3++]) * 0.25;
            ny = (verts[v0++] + verts[v1++] + verts[v2++] + verts[v3++]) * 0.25;
            nz = (verts[v0++] + verts[v1++] + verts[v2++] + verts[v3++]) * 0.25;
            
            nml[ni++] = nx; nml[ni++] = ny; nml[ni++] = nz;
            nml[ni++] = nx; nml[ni++] = ny; nml[ni++] = nz;
            nml[ni++] = nx; nml[ni++] = ny; nml[ni++] = nz;
            nml[ni++] = nx; nml[ni++] = ny; nml[ni++] = nz;
            nml[ni++] = nx; nml[ni++] = ny; nml[ni++] = nz;
            nml[ni++] = nx; nml[ni++] = ny; nml[ni++] = nz;
          }  
        }
        

        model = {
          subdivcube : subdivcube,
          
          pos : gl.newBuffer(pos, 3, gl.FLOAT),
          col : gl.newBuffer(col, 3, gl.FLOAT),
          nml : gl.newBuffer(nml, 3, gl.FLOAT),
          
          display : function(shader){
            shader.attribute('pos', this.pos);
            shader.attribute('col', this.col);
            shader.attribute('nml', this.nml);
            gl.drawArrays(gl.TRIANGLES, 0, this.pos.vtxCount);
          },
        };
      }
      
      
      app.resize = function(w, h){
      }

      
      app.draw = function(){
        var w = canvas.width;
        var h = canvas.height;
        
        // projection
        mat4.perspective(m4_projection, 60 * Dw.TO_RAD, w/h, 1, 20000);
        mat4.scale(m4_projection, m4_projection, [1,-1,1]);
      
        // camera
        mat4.identity(m4_modelview);
        
        // apply cam
        orbit.update().apply(m4_modelview);
        
        mat4.scale(m4_modelview, m4_modelview, [300, 300, 300]);
        
        // normal matrix: inverse transpose modelview
        mat3.normalFromMat4(m3_normals, m4_modelview);

        var gray = 8.0 / 255.0;
        
        gl.viewport(0, 0, w, h);
        gl.colorMask(true, true, true, true);
        gl.depthMask(true);
        gl.disable(gl.BLEND);
        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(gray, gray, gray, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
      
        // apply shader
        shader.begin();
        shader.uniformM('m4_projection', m4_projection);
        shader.uniformM('m4_modelview', m4_modelview);
        shader.uniformM('m3_normals', m3_normals);
        model.display(shader);
        shader.end();
        
        HUD();
      }
      
      app.release = function(){
        console.log("release");
      }
      
      function HUD(){
        var w = canvas.width;
        var h = canvas.height;
        var fps = app.framerate;
        var stats = '';
        stats += 'wh: '+w+'/'+h;
        stats += ' - fps: '+fps.toFixed(2);
        stats += ' - verts: '+model.subdivcube.verts_num;
        stats += ' - faces: '+model.subdivcube.faces_num;
        stats += ' - subdiv: '+model.subdivcube.subdiv;
        document.getElementById('sketch-stats').textContent = stats;
      }
      
    });
    
    
   
    
    
  </script>
  
</body>

</html>

