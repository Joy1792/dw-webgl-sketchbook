<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  
  <script src="../lib/gl-matrix-2.4.0/gl-matrix-min.js"></script>
  <script src="../lib/dat.gui-0.6.5/dat.gui.min.js"></script>
  
  <script src="../dwgl/dw_gl.js"></script>
  <script src="../dwgl/dw_utils.js"></script>
  <script src="../dwgl/dw_app.js"></script>
  <script src="../dwgl/dw_orbit.js"></script>
  <script src="../dwgl/dw_easycam.js"></script>
  <script src="../dwgl/dw_geometry.js"></script>
  
  <link rel="stylesheet" href="../css/style.css">


<script>
/**
 *
 *  dw-webgl-sketchbook: https://github.com/diwi/dw-webgl-sketchbook
 *
 *  Copyright 2018 by Thomas Diewald, https://www.thomasdiewald.com
 *
 *  MIT License: https://opensource.org/licenses/MIT
 *
 */
</script>

<script id="webgl2.vs_depthmap" type="x-shader/x-fragment">
  #version 300 es

  #ifdef GL_ES
    precision highp float;
    precision highp int;
  #endif
  
  in vec3 pos;

  uniform mat4 m4_projection;
  uniform mat4 m4_modelview;

  void main(){
    gl_Position = m4_projection * m4_modelview * vec4(pos, 1.0);
  }
    
</script>

<script id="webgl2.fs_depthmap" type="x-shader/x-fragment">
  #version 300 es

  #ifdef GL_ES
    precision highp float;
    precision highp int;
  #endif
  
  void main(){
  }
</script>


<script id="webgl2.fs_texdisplay" type="x-shader/x-fragment">
  #version 300 es

  #ifdef GL_ES
    precision highp float;
    precision highp int;
  #endif
  
  uniform vec2 wh_rcp;
  uniform vec2 xy_off;
  uniform sampler2D tex;
  
  out vec4 fragcol;
  
  void main(){
    vec2 posn = (gl_FragCoord.xy - xy_off) * wh_rcp;
    float depth = texture(tex, posn).x;
    depth = depth ;
    fragcol = vec4(1.0);
    fragcol.rgb = vec3(1.0 - depth);
  }
</script>




<script id="webgl2.vs_draw" type="x-shader/x-fragment">
  #version 300 es

  #ifdef GL_ES
    precision highp float;
    precision highp int;
  #endif
  
  in vec3 pos;
  in vec3 col;
  in vec3 nml;
  in int  mID;
  
  out vec3 vpos;
  out vec3 vcol;
  out vec3 vnml;
  flat out int vmID;
  
  uniform mat4 m4_projection;
  uniform mat4 m4_modelview;
  uniform mat3 m3_normals;

  void main(){
    gl_Position = m4_projection * m4_modelview * vec4(pos, 1.0);
    vpos = (m4_modelview * vec4(pos, 1.0)).xyz;
    vcol = col;
    vnml = nml;
    vmID = mID;
  }
</script>



<script id="webgl2.fs_draw" type="x-shader/x-fragment">
  #version 300 es

  #ifdef GL_ES
    precision highp float;
    precision highp int;
  #endif
  
  struct Ambientlight{
    vec3 col;
  };
  
  struct DirectionalLight {
    vec3 dir;
    vec3 col;
  };
  
  struct Material {
    vec3  diff;
    vec3  spec;
    float spec_exp;
    float normalsmooth;
  };
  
  in vec3 vpos;
  in vec3 vcol;
  in vec3 vnml;
  flat in int vmID;
    
  out vec4 outfragcol;
  
  uniform mat4 m4_projection;
  uniform mat4 m4_modelview;
  uniform mat3 m3_normals;
  
  // lights
  uniform Ambientlight ambientlight;
  
  #define NUM_DIRECTIONALLIGHTS 1
  uniform DirectionalLight directionallights[NUM_DIRECTIONALLIGHTS];
  
  // materials
  #define NUM_MATERIALS 8
  uniform Material materials[NUM_MATERIALS];
  
  // fragment material, based on vertex attribute "mid"
  Material material;
  
  vec3 getFragmentNormal(vec3 vertPos){
    vec3 fnormal = normalize(cross(dFdx(vertPos), -dFdy(vertPos)));
    vec3 vnormal = normalize(m3_normals * vnml) * (gl_FrontFacing ? 1.0 : -1.0);
    return normalize(mix(fnormal, vnormal, material.normalsmooth));
    // return vnormal;
    // return fnormal;
  }

  float getKd(vec3 vertNormal, vec3 lightDir){
    return max(dot(-lightDir, vertNormal), 0.0);
  }
  
  float getKs(vec3 vertNormal, vec3 lightDir, vec3 vertDir){
    vec3 lightDirReflected = normalize(reflect(lightDir, vertNormal));
    return pow(max(dot(lightDirReflected, vertDir), 0.0), material.spec_exp);
  }
  
  void main(){
    
    material = materials[vmID];
    
    vec3 vertPos = vpos;
    vec3 vertDir = normalize(-vertPos);
    vec3 vertNml = getFragmentNormal(vertPos);

    // summed up light contributions
    vec3 fragcol = vec3(0.0);
    
    // ambientlight
    {
      fragcol += material.diff * ambientlight.col;
    }
    
    // directionallights
    for(int i = 0; i < NUM_DIRECTIONALLIGHTS; i++) {
      
      DirectionalLight light = directionallights[i];
    
      // light direction
      vec3 lightDir = normalize(light.dir);
   
      // diffuse, specular
      float kd = getKd(vertNml, lightDir);
      float ks = getKs(vertNml, lightDir, vertDir) * kd;
      
      fragcol += material.diff * light.col * kd;
      fragcol += material.spec * light.col * ks;
    }
      
    // [0,1]
    fragcol = clamp(fragcol, 0.0, 1.0);
    
    // gamma 2.2
    fragcol = pow(fragcol, vec3(1.0/2.2));

    // frag, out
    outfragcol = vec4(fragcol, 1);
  }
  
</script>

    
</head>
<body>

  <div id="hud">
    <div id="sketch-title"></div>
    <div id="sketch-stats"></div>
    <div id="sketch-controls"></div>
  </div>
  
  <script>

    'use strict';
    
    document.oncontextmenu = function() { return false; }
    document.onmousedown   = function() { return false; }

    var app;
    var canvas;
    var gl;
    
    var shader;
    var shader_texdisplay;

    var depthmap;

    var groundplane;

    var models = [];
    
    var m4_modelview  = newMat(mat4);
    var m4_projection = newMat(mat4);
    var m3_normals    = newMat(mat3);
   
    
    var orbit;
    var orbit_light;
    
    function init(){
      console.log(this);
      console.log(Dw);
      app = this;
      app.webgl_attributes.antialias = true;
    }
    
    function newMat(matX){
      var mat = matX.create();
      
      mat.stack = [];
      mat.push =  function(){
        this.stack.push(matX.clone(this));
      }
      
      mat.pop =  function(){
        matX.copy(this, this.stack.pop());
      }
      
      if(matX === mat4){
        mat.translate = function(x,y,z){
          matX.translate(this, this, [x,y,z]);
        }
      }
      
      return mat;
    }
    
    
    var setup = function(){
      
      canvas = this.canvas;
      gl = this.gl;
      
      var w = canvas.width;
      var h = canvas.height;
      

      // orbit = new Dw.OrbitControl(this);
      orbit = new Dw.EasyCam(this, {distance: 3000});
      
            
      orbit_light = new Dw.EasyCam(this, {distance: 3000});
      orbit_light.setViewport([10,h-300-10, 300, 300]);
      
      orbit.exclude.add(orbit_light);

      
      
      // create Shader
      var vs, fs;
      vs = document.getElementById("webgl2.vs_draw").textContent;
      fs = document.getElementById("webgl2.fs_draw").textContent;
      shader = new Dw.Shader(gl, {vs:vs, fs:fs});
     
      
      fs = document.getElementById("webgl2.fs_texdisplay").textContent;
      shader_texdisplay = new Dw.Shader(gl, {fs:fs});
      
      
      var icos     = Dw.createIcosahedron(300, 1);
      var cube     = Dw.createCube(300, 1);
      var sphere   = Dw.createSphere(300, 8, 4);
      var plane    = Dw.createPlane(300);
      var torus    = Dw.createTorus(300);  
      var box      = Dw.createBox(300, 300, 300, 1, 1, 30);  
      var circle   = Dw.createCircle(300, 16, !true);  
      var tube     = Dw.createTube(300, 0, 300, 12, 1);  
      var cylinder = Dw.createCylinder(300, 300, 300, 64, 1);
        
      groundplane = new Model(Dw.createPlane(3000), 0); 
      
      var i = 0;
      models[i++] = new Model(icos    , 1);
      models[i++] = new Model(cube    , 1);
      models[i++] = new Model(sphere  , 1);
      models[i++] = new Model(plane   , 2);
      models[i++] = new Model(torus   , 3);
      models[i++] = new Model(box     , 4); 
      models[i++] = new Model(circle  , 5);
      models[i++] = new Model(tube    , 6);
      models[i++] = new Model(cylinder, 7);
      
      depthmap = new DepthMap();
      depthmap.setOrtho(3000,-3000,6000);
      // depthmap.setPerspective(60 * Dw.TO_RAD, 100, 4000);
      initGUI();
    }
    
    
   
    class Model {
      
      constructor(ifs, materialID){
        this.ifs = ifs;
        
        materialID = materialID || 0;
        ifs.mID = new Int32Array(ifs.verts_num);
        for(var i = 0; i < ifs.verts_num; i++){
          ifs.mID[i] = materialID;
        }

        this.pos = gl.newBuffer(ifs.verts, 3, gl.FLOAT);
        this.col = gl.newBuffer(ifs.verts, 3, gl.FLOAT);
        this.vnm = gl.newBuffer(ifs.vnml, 3, gl.FLOAT);
        this.mID = gl.newBuffer(ifs.mID, 1, gl.INT);
        this.idx = gl.newBuffer(ifs.triangles, 1, gl.UNSIGNED_INT, gl.ELEMENT_ARRAY_BUFFER);
      }
     
      release(){
        this.pos.release();
        this.col.release();
        this.vnm.release();
        this.mID.release();
        this.idx.release();
      }
   
      display(shader){
        shader.attributeF('pos', this.pos);
        shader.attributeF('col', this.col);
        shader.attributeF('nml', this.vnm);
        shader.attributeI('mID', this.mID);
        this.idx.bind();
        gl.frontFace(gl.CW);
        gl.disable(gl.CULL_FACE);
        gl.drawElements(gl.TRIANGLES, this.idx.vtxCount, this.idx.type, 0);
      }

    };
    

    var resize = function(w, h){
    }
    

    var initGUI = function(){
      var aGui = new dat.GUI();

      var cAL = aGui.addFolder('Ambient Light');
      var cALcol = cAL.addColor(ambientlight, 'col');
      
      var cDL = aGui.addFolder('Directional Lights');
      var dDL = [];
      for(var i = 0; i < directionallights.length; i++){
        dDL[i] = cDL.addFolder('DL '+i);
        dDL[i].addColor(directionallights[i], 'col');
      }
      dDL[0].open();
      
      var bMaterials = aGui.addFolder('Materials');
      bMaterials.open();
      var cMat = [];
      for(var i = 1; i < materials.length; i++){
        cMat[i] = bMaterials.addFolder('Material '+i);
        cMat[i].add     (materials[i], 'spec_exp'    , 1, 500  );
        cMat[i].add     (materials[i], 'normalsmooth', 0, 1.00  );
        cMat[i].addColor(materials[i], 'diff');
        cMat[i].addColor(materials[i], 'spec');
      }
      cMat[1].open();
    }
    
    
    var materials = [
      { diff:[255,220,220], spec:[255,220,220], spec_exp:50 , normalsmooth: 0.80 },
      { diff:[ 32, 32, 32], spec:[255,255,255], spec_exp:50 , normalsmooth: 0.80 },
      { diff:[255,255,255], spec:[255,255,255], spec_exp:50 , normalsmooth: 0.80 },
      { diff:[255, 16,  4], spec:[255,220,192], spec_exp:50 , normalsmooth: 1.00 },  
      { diff:[255,255,255], spec:[255,255,255], spec_exp:50 , normalsmooth: 0.80 },  
      { diff:[  8,  16, 4], spec:[255,255,255], spec_exp:50 , normalsmooth: 0.80 },  
      { diff:[  4,  8, 16], spec:[128,128,255], spec_exp:16 , normalsmooth: 0.00 },  
      { diff:[ 16,  8,  4], spec:[255,128,128], spec_exp:16 , normalsmooth: 1.00 },  
    ];
    
    var ambientlight = { col : [2,1,2] };

    var directionallights = [
      { dir:[-1,-1,-1], dir_cam:[0,0,0], col:[255,255,255] },
    ];

    
    function normCol(col){
      return [col[0] / 255, col[1] / 255, col[2] / 255];
    }
    
    function setMaterial(shader, idx){
      var material = materials[idx];
      shader.uniformF('materials['+idx+'].diff'        , normCol(material.diff));
      shader.uniformF('materials['+idx+'].spec'        , normCol(material.spec));
      shader.uniformF('materials['+idx+'].spec_exp'    , material.spec_exp);
      shader.uniformF('materials['+idx+'].normalsmooth', material.normalsmooth);
    }

    function setAmbientlight(shader, ambientlight){ 
      shader.uniformF('ambientlight.col', normCol(ambientlight.col));
    }

    function setDirectionalLight(shader, idx){
      
      var light = directionallights[idx];
      // transform to camera-space 
      mat3.normalFromMat4(m3_normals, m4_modelview);
      vec3.transformMat3(light.dir_cam, light.dir, m3_normals);
      
      // set shader uniforms
      shader.uniformF('directionallights['+idx+'].dir', light.dir_cam);
      shader.uniformF('directionallights['+idx+'].col', normCol(light.col));
    }
    
    
    
    class DepthMap{
      
      constructor(){
        var vs = document.getElementById("webgl2.vs_depthmap").textContent;
        var fs = document.getElementById("webgl2.fs_depthmap").textContent;
        this.shader = new Dw.Shader(gl, {vs:vs, fs:fs});
        
        var dim = 1024;
        var def = {
          target     : gl.TEXTURE_2D,
          iformat    : gl.DEPTH_COMPONENT16,
          format     : gl.DEPTH_COMPONENT,
          attachment : gl.DEPTH_ATTACHMENT,
          type       : gl.UNSIGNED_SHORT,
          wrap       : gl.CLAMP_TO_EDGE,
          filter     : [gl.NEAREST, gl.NEAREST],
        };

        this.tex = gl.newTexture(dim, dim, def);
        
        this.fbo = gl.newFramebuffer();
        this.fbo.setTexture(this.tex);
        this.fbo.err();
        
        this.fbo.begin();
        this.fbo.end();
        
        this.mat = {
          modelview  : newMat(mat4),
          projection : newMat(mat4),
        };
      }
      
      resize(w, h){
        this.tex.resize(w, h);
      }
      
      setModelview(dir, distance){
        var x = dir[0];
        var y = dir[1];
        var z = dir[2];
        var dd = x*x+y*y+z*z;
        if(dd > 0.0 && dd !== 1.0){
          dd = distance / Math.sqrt(dd);
          x *= dd;
          y *= dd;
          z *= dd;
        }
  
        this.eye    = [-x,-y,-z];
        this.center = [0,0,0];
        this.up     = [0,0,-1];
        mat4.lookAt(this.mat.modelview,this. eye, this.center, this.up);
      }
      
      setOrtho(w, h, d){
        mat4.ortho(this.mat.projection, -w/2, w/2, -h/2, h/2, 0, d);
      }
      
      setPerspective(fovy, near, far){
        mat4.perspective(this.mat.projection, fovy, this.tex.w/this.tex.h, near, far);
        mat4.scale(this.mat.projection, this.mat.projection, [1,-1,1]);
      }
      
      create(render_cb){
        var w = this.tex.w;
        var h = this.tex.h;
        
        this.fbo.begin();
        
        gl.viewport(0, 0, w, h);
        gl.colorMask(false, false, false, false);
        gl.depthMask(true);
        gl.disable(gl.BLEND);
        gl.enable(gl.DEPTH_TEST);
        // gl.clearDepth(1.0);
        gl.clear(gl.DEPTH_BUFFER_BIT);
       
        this.shader.begin();
        this.shader.pushAttributeLocWarning(false);
        this.shader.pushUniformLocWarning(false);
        render_cb(this.shader, this.mat);
        this.shader.popAttributeLocWarning();
        this.shader.popUniformLocWarning();
        this.shader.end();
        this.fbo.end();
      }
    
    }

    
    function draw(){
      var w = canvas.width;
      var h = canvas.height;
      

      
      
      // projection
      mat4.perspective(m4_projection, 60 * Dw.TO_RAD, w/h, 100, 6000);
      mat4.scale(m4_projection, m4_projection, [1,-1,1]);
    
      // camera
      mat4.identity(m4_modelview);
      

      orbit.update().apply(m4_modelview);
      
      mat3.normalFromMat4(m3_normals, m4_modelview);
      
      
      // mat4.copy(depthmap.mat.modelview, m4_modelview);
      // mat4.copy(depthmap.mat.projection, m4_projection);
      
      // console.log(depthmap.mat.modelview, m4_modelview)
      
      orbit_light.update().apply(depthmap.mat.modelview);

      depthmap.create(displayScene);
      
      var camEYE = orbit_light.getPosition(this.camEYE);   
      var camLAT = orbit_light.getCenter  (this.camLAT);
      var camRUP = orbit_light.getUpVector(this.camRUP);
      
            
      directionallights[0].dir[0] =  camLAT[0] - camEYE[0];
      directionallights[0].dir[1] =  camLAT[1] - camEYE[1];
      directionallights[0].dir[2] =  camLAT[2] - camEYE[2];
      
      
      
      // directionallights[0].dir[0] = depthmap.mat.modelview[8];
      // directionallights[0].dir[1] = depthmap.mat.modelview[9];
      // directionallights[0].dir[2] = -depthmap.mat.modelview[10];
      

      
      var gray = 16.0 / 255.0;
      gl.viewport(0, 0, w, h);
      gl.colorMask(true, true, true, true);
      gl.depthMask(true);
      gl.disable(gl.BLEND);
      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(gray, gray, gray, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
      
      shader.frag.setDefine('NUM_DIRECTIONALLIGHTS', directionallights.length);
      shader.frag.setDefine('NUM_MATERIALS'        , materials.length);

      shader.begin();

      // materials 
      for(var i = 0; i < materials.length; i++){
        setMaterial(shader, i);
      }
      
      // ambient light
      setAmbientlight(shader, ambientlight);
      
      setDirectionalLight(shader, 0);
      
      var mat = {
        projection : m4_projection,
        modelview : m4_modelview,
        normals : m3_normals,
      }
      
      displayScene(shader, mat);
      
      shader.end();
      
      displayDepthmap();

      HUD();
    }
    
    
    function displayDepthmap(){
      
      var w_canvas = app.canvas.width;
      var h_canvas = app.canvas.height;
      
      var viewport = orbit_light.getViewport();
      
      var w = viewport[2];
      var h = viewport[3];
      var x = viewport[0];
      var y = viewport[1]; y = h_canvas - 1 - y - h;

      shader_texdisplay.begin();
      gl.viewport(x, y, w, h);
      gl.colorMask(true, true, true, true);
      gl.disable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      shader_texdisplay.uniformF('xy_off', [x, y]);
      shader_texdisplay.uniformF('wh_rcp', [1/w, 1/h]);
      shader_texdisplay.uniformT('tex', depthmap.tex);
      shader_texdisplay.quad();
      shader_texdisplay.end();
    }
    
    
    function displayScene(shader, mat){
      // groundplane
      mat.modelview.push();
      mat.modelview.translate(0, 0, 0);
      shader.uniformM('m4_projection', mat.projection);
      shader.uniformM('m4_modelview' , mat.modelview );
      shader.uniformM('m3_normals', mat.normals   );

      groundplane.display(shader);
      mat.modelview.pop();
      
      // evenly space primitives
      var spacing = 900;
      var nx = Math.ceil(Math.sqrt(models.length));
      var ny = models.length / nx;
      var dimx = spacing * (nx-1);
      var dimy = spacing * (ny-1);
      
      mat.modelview.push();
      mat.modelview.translate(-dimx/2, -dimy/2, 400);

      for(var iy = 0; iy < ny; iy++){
       
        mat.modelview.push();
        for(var ix = 0; ix < nx; ix++){
          
          var idx = iy * nx + ix;
          if(idx < models.length){
            shader.uniformM('m4_projection', mat.projection);
            shader.uniformM('m4_modelview' , mat.modelview );
            shader.uniformM('m3_normals', mat.normals   );
            models[idx].display(shader);
          }
          mat.modelview.translate(spacing, 0, 0);
        }
        mat.modelview.pop();
        mat.modelview.translate(0, spacing, 0);
      }
      mat.modelview.pop();

    }
    
    
    
    

    var release = function(){
      shader.release();
      groundplane.release();
      for(var i = 0; i < models.length; i++){
        models[i].release();
      }
    }
    
    function HUD(){
      var w = canvas.width;
      var h = canvas.height;
      var fps = app.framerate;
      var stats = '';
      stats += 'wh: '+w+'/'+h;
      stats += ' - fps: '+fps.toFixed(2);
      document.getElementById('sketch-stats').textContent = stats;
    }
    
    


    Dw.start('ShadowMapping');

  </script>
  
</body>

</html>

